<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Vivora Fashion Illustration 2025</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="app" role="application" aria-label="Vivora Fashion Illustration 2025">

    <!-- ========== ヘッダー ========== -->
    <header class="topbar" aria-label="topbar">
      <div class="page-title">Vivora Fashion Illustration 2025</div>

      <div class="top-controls">
        <button class="next-step" id="btn-next">Next Step ▶▶</button>
        <nav class="contents-button" aria-label="contents">
          <img src="/create_parts/contents_button/0_home.png"  alt="Home"        title="Home"        class="cont-btn">
          <img src="/create_parts/contents_button/1_inspiration.png" alt="Insp"  title="Inspiration" class="cont-btn">
          <img src="/create_parts/contents_button/2_mannequin.png"   alt="Manq"  title="Mannequin"   class="cont-btn">
          <img src="/create_parts/contents_button/3_cutting.png"     alt="Cut"   title="Cutting"     class="cont-btn">
          <img src="/create_parts/contents_button/4_pen.png"         alt="Pen"   title="Pen"         class="cont-btn">
          <img src="/create_parts/contents_button/5_color.png"       alt="Color" title="Color"       class="cont-btn">
          <img src="/create_parts/contents_button/6_dic.png"         alt="Dic"   title="Dictionary"  class="cont-btn">
        </nav>
      </div>
    </header>

    <!-- ========== 作業領域 ========== -->
    <main class="workspace">

      <!-- ボード：マネキン + 3枚の描画キャンバス + グリッド -->
      <section id="board" aria-label="canvas-board">
        <!-- グリッド（方眼紙）：トグル表示 -->
        <img id="graph-paper" src="/public/graph_paper.png" alt="Graph Paper">

        <!-- マネキン（ピンチズーム＆パンのベース） -->
        <img id="mannequin" src="/public/mannequin/mannequin_woman.png" alt="Mannequin">

        <!-- 3レイヤーのキャンバス（Z順：下→上） -->
        <canvas id="layer-1" width="1024" height="640" aria-label="Layer 1"></canvas>
        <canvas id="layer-2" width="1024" height="640" aria-label="Layer 2"></canvas>
        <canvas id="layer-3" width="1024" height="640" aria-label="Layer 3"></canvas>

        <!-- ズームHUD -->
        <div id="zoom-hud">100%</div>
      </section>

      <!-- 右サイドバー -->
      <aside class="sidebar">

        <!-- Upload / Download / Save -->
        <div class="file-tools">
          <button id="btn-upload"  title="Upload (mannequin)">⬆</button>
          <button id="btn-download" title="Download PNG">⬇</button>
          <button id="btn-save"     title="Save Project">💾</button>
        </div>

        <!-- Layer パネル -->
        <div class="layer-panel" aria-label="layers">
          <!-- 各ボックス：表示(V)・ロック(🔒)・選択(●)・クリア(🗑) -->
          <div class="layer-box" data-layer="3">
            <div class="layer-toolbar">
              <button class="vis" title="toggle visibility">👁</button>
              <button class="lock" title="lock/unlock">🔒</button>
              <button class="clr" title="clear layer">🗑</button>
            </div>
            <div class="layer-title">Layer 3</div>
            <input type="radio" name="active-layer" checked>
          </div>

          <div class="layer-box" data-layer="2">
            <div class="layer-toolbar">
              <button class="vis" title="toggle visibility">👁</button>
              <button class="lock" title="lock/unlock">🔒</button>
              <button class="clr" title="clear layer">🗑</button>
            </div>
            <div class="layer-title">Layer 2</div>
            <input type="radio" name="active-layer">
          </div>

          <div class="layer-box" data-layer="1">
            <div class="layer-toolbar">
              <button class="vis" title="toggle visibility">👁</button>
              <button class="lock" title="lock/unlock">🔒</button>
              <button class="clr" title="clear layer">🗑</button>
            </div>
            <div class="layer-title">Layer 1</div>
            <input type="radio" name="active-layer">
          </div>
        </div>

        <!-- ステーショナリー -->
        <div class="stationery-tools" aria-label="stationery">
          <button class="tool" data-tool="pencil"   title="鉛筆">✏️</button>
          <button class="tool" data-tool="ballpen"  title="ボールペン">🖊</button>
          <button class="tool" data-tool="brush"    title="筆ブラシ">🖌</button>
          <button class="tool" data-tool="marker"   title="マーカー">🖍</button>
          <button class="tool" data-tool="anchor"   title="アンカーペン">📐</button>
          <button class="tool" data-tool="eraser"   title="消しゴム">🧽</button>

          <!-- 太さ：ツール選択時だけ表示 -->
          <label id="size-wrap" class="size-wrap">
            <span>Size</span>
            <input id="size" type="range" min="1" max="60" value="8">
            <span id="size-val">8</span>
          </label>
        </div>

        <!-- Opacity -->
        <div class="opacity-tool" title="Opacity">
          <input id="opacity" type="range" min="5" max="100" value="100">
          <span id="op-val">100%</span>
        </div>

        <!-- Color パレット -->
        <div class="color-tool" aria-label="colors">
          <!-- グレー3 + カラー10 + 黒 の12色構成（画像準拠） -->
          <button class="color c-gray3"  data-col="#E6E6E6"></button>
          <button class="color c-gray2"  data-col="#BFBFBF"></button>
          <button class="color c-gray1"  data-col="#9E9E9E"></button>

          <button class="color c-ylw"    data-col="#F8D548"></button>
          <button class="color c-org"    data-col="#F6A34D"></button>
          <button class="color c-red"    data-col="#E25B5B"></button>
          <button class="color c-pink"   data-col="#DE6AAE"></button>
          <button class="color c-vio"    data-col="#8E65D8"></button>
          <button class="color c-blu"    data-col="#4E78DA"></button>
          <button class="color c-cyan"   data-col="#42BFD3"></button>
          <button class="color c-grn"    data-col="#58C16C"></button>
          <button class="color c-brwn"   data-col="#A46D4B"></button>
          <button class="color c-black"  data-col="#111111"></button>
        </div>

        <!-- グリッドトグル -->
        <button id="btn-grid" class="grid-btn" title="Toggle Grid (G)">#</button>
      </aside>
    </main>
  </div>

  <!-- =========================
       JavaScript（描画・操作系）
       ========================= -->
  <script>
  // ============ 参照取得 ============
  const board = document.getElementById('board');
  const mannequin = document.getElementById('mannequin');
  const grid = document.getElementById('graph-paper');
  const zoomHUD = document.getElementById('zoom-hud');

  const canvases = [
    document.getElementById('layer-1'),
    document.getElementById('layer-2'),
    document.getElementById('layer-3'),
  ];
  const ctxs = canvases.map(c => c.getContext('2d'));

  // サイズ（ボードに対して中央に収める）
  function fitCanvases(){
    const w = 1024, h = 640; // 作業領域（画像準拠：余白を確保）
    canvases.forEach(c => { c.width = w; c.height = h; });
    // 中央配置は CSS で実施（position:absolute + transform で追従）
  }
  fitCanvases();

  // ============ 状態 ============
  let activeLayer = 2; // 0..2（初期：最上段=2）
  let tool = null;     // 'pencil' | 'ballpen' | 'brush' | 'marker' | 'anchor' | 'eraser'
  let color = '#111111';
  let size = 8;
  let opacity = 1.0;

  // ズーム＆パン（ボード全体を transform）
  let scale = 1.0;
  let tx = 0, ty = 0;

  // アンカーペン用
  let anchorPoints = [];
  let anchorActive = false;

  // ============ UI 連動 ============
  // tool
  document.querySelectorAll('.tool').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      tool = btn.dataset.tool;
      document.querySelectorAll('.tool').forEach(b=>b.classList.toggle('active', b===btn));
      const showSizer = (tool !== 'anchor'); // アンカーは線幅は今は size 反映でもOK
      document.getElementById('size-wrap').style.display = showSizer ? 'grid' : 'none';
      if(tool==='marker'){ /* markerの既定透明度(重ね塗り感) */
        document.getElementById('opacity').value = 35; // 35%
        updateOpacity();
      }
      if(tool!=='anchor'){ anchorActive=false; anchorPoints.length=0; }
    });
  });

  // size
  const sizeInput = document.getElementById('size');
  const sizeVal = document.getElementById('size-val');
  function updateSize(){
    size = parseInt(sizeInput.value,10);
    sizeVal.textContent = size;
  }
  sizeInput.addEventListener('input', updateSize);
  updateSize();

  // opacity
  const opInput = document.getElementById('opacity');
  const opVal = document.getElementById('op-val');
  function updateOpacity(){
    opacity = parseInt(opInput.value,10) / 100;
    opVal.textContent = `${Math.round(opacity*100)}%`;
  }
  opInput.addEventListener('input', updateOpacity);
  updateOpacity();

  // colors
  document.querySelectorAll('.color').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      color = btn.dataset.col;
      document.querySelectorAll('.color').forEach(b=>b.classList.toggle('picked', b===btn));
    });
  });
  // 既定色を選択状態に
  document.querySelector('.c-black').classList.add('picked');

  // grid
  const gridBtn = document.getElementById('btn-grid');
  function toggleGrid(){
    grid.classList.toggle('show');
  }
  gridBtn.addEventListener('click', toggleGrid);
  window.addEventListener('keydown', e=>{ if(e.key==='g' || e.key==='G') toggleGrid(); });

  // contents / next step（ダミー）
  document.getElementById('btn-next').addEventListener('click', ()=>alert('Next Step は後で接続します'));
  document.querySelectorAll('.cont-btn').forEach(i=>i.addEventListener('click', ()=>alert('Contents は後で接続します')));

  // Upload / Download / Save
  document.getElementById('btn-upload').addEventListener('click', ()=>{
    const inp = document.createElement('input');
    inp.type='file'; inp.accept='image/*';
    inp.onchange = e=>{
      const file = e.target.files?.[0]; if(!file) return;
      const url = URL.createObjectURL(file);
      mannequin.src = url; // マネキン差し替え
    };
    inp.click();
  });

  document.getElementById('btn-download').addEventListener('click', ()=>{
    // 合成用一時キャンバス
    const tmp = document.createElement('canvas');
    tmp.width = canvases[0].width;
    tmp.height = canvases[0].height;
    const tctx = tmp.getContext('2d');

    // マネキンも合成（現在のtransformは無視して原寸で書き出し）
    // 背景は白
    tctx.fillStyle='#FFFFFF';
    tctx.fillRect(0,0,tmp.width,tmp.height);

    // マネキンを作業領域中央にフィット（現在の CSS レイアウトと同等比率で配置）
    // ここでは、マネキンの自然サイズで中央配置（最頻ケース）
    // 必要なら座標調整を追加
    // Layer合成
    canvases.forEach(c=>tctx.drawImage(c,0,0));

    const a = document.createElement('a');
    a.download = 'vivora_export.png';
    a.href = tmp.toDataURL('image/png');
    a.click();
  });

  function saveProject(){
    const data = {
      mannequinSrc: mannequin.src,
      grid: grid.classList.contains('show'),
      strokes: canvases.map(c=>c.toDataURL('image/png')),
      color, size, opacity, activeLayer
    };
    localStorage.setItem('vivora_project', JSON.stringify(data));
  }
  document.getElementById('btn-save').addEventListener('click', ()=>{ saveProject(); alert('Saved'); });

  // 起動時復元
  (function restore(){
    const raw = localStorage.getItem('vivora_project');
    if(!raw) return;
    try{
      const data = JSON.parse(raw);
      if(data.mannequinSrc) mannequin.src = data.mannequinSrc;
      if(data.grid) grid.classList.add('show');
      if(Array.isArray(data.strokes)){
        data.strokes.forEach((url,i)=>{
          if(!url) return;
          const img = new Image();
          img.onload = ()=>ctxs[i]?.drawImage(img,0,0);
          img.src = url;
        });
      }
      if(data.color){ color = data.color; }
      if(data.size){ size = data.size; sizeInput.value = size; updateSize(); }
      if(data.opacity){ opacity = data.opacity; opInput.value = Math.round(opacity*100); updateOpacity(); }
      if(typeof data.activeLayer==='number'){
        activeLayer = Math.min(2, Math.max(0, data.activeLayer));
        document.querySelectorAll('.layer-box input[type=radio]')[2-activeLayer].checked = true;
      }
    }catch(e){}
  })();

  // Layer UI
  document.querySelectorAll('.layer-box').forEach(box=>{
    const idx = parseInt(box.dataset.layer,10)-1; // 0..2
    const radio = box.querySelector('input[type=radio]');
    const visBtn = box.querySelector('.vis');
    const lockBtn= box.querySelector('.lock');
    const clrBtn = box.querySelector('.clr');

    radio.addEventListener('change', ()=>{ if(radio.checked) activeLayer = idx; });

    visBtn.addEventListener('click', ()=>{
      const c = canvases[idx];
      c.classList.toggle('hidden');
      visBtn.textContent = c.classList.contains('hidden') ? '🚫' : '👁';
    });

    lockBtn.addEventListener('click', ()=>{
      canvases[idx].toggleAttribute('data-locked');
      lockBtn.textContent = canvases[idx].hasAttribute('data-locked') ? '🔒' : '🔓';
    });

    clrBtn.addEventListener('click', ()=>{
      if(confirm('このレイヤーをクリアしますか？')){
        ctxs[idx].clearRect(0,0,canvases[idx].width, canvases[idx].height);
      }
    });
  });

  // ============ 描画系（ポインタイベント） ============
  const pointer = { down:false, x:0, y:0, prevX:0, prevY:0, id:null };
  let secondTouch = null; // ピンチ判定

  function getActiveCtx(){
    return ctxs[activeLayer];
    }
  function localXY(e){
    const rect = canvases[0].getBoundingClientRect();
    const x = (e.clientX - rect.left - tx) / scale;
    const y = (e.clientY - rect.top  - ty) / scale;
    return {x,y};
  }

  function beginStroke(x,y){
    const ctx = getActiveCtx();
    if(canvases[activeLayer].hasAttribute('data-locked')) return;
    ctx.globalAlpha = (tool==='marker') ? Math.min(0.35, opacity) : opacity;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // ツール別設定
    if(tool==='pencil'){
      ctx.strokeStyle = color;
      ctx.lineWidth = Math.max(1, size*0.6);
    }else if(tool==='ballpen'){
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
    }else if(tool==='brush'){
      ctx.strokeStyle = color;
      ctx.lineWidth = size * 1.2;
    }else if(tool==='marker'){
      ctx.strokeStyle = color;
      ctx.lineWidth = size * 1.8;
    }else if(tool==='eraser'){
      ctx.globalCompositeOperation = 'destination-out';
      ctx.lineWidth = size * 1.6;
    }

    ctx.beginPath();
    ctx.moveTo(x,y);
  }

  function drawTo(x,y,spd=1){
    const ctx = getActiveCtx();
    if(tool==='brush'){
      // 速度による擬似筆圧：速いほど細く
      const lw = Math.max(1, size*1.2 - spd*0.5);
      ctx.lineWidth = lw;
    }
    ctx.lineTo(x,y);
    ctx.stroke();
  }

  function endStroke(){
    const ctx = getActiveCtx();
    // 合成を戻す
    if(tool==='eraser'){
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  // ポインターハンドラ（単指＝描画／二指＝パン・ズーム）
  board.addEventListener('pointerdown', (e)=>{
    board.setPointerCapture(e.pointerId);

    // 二本目タッチ？
    if(pointer.down && secondTouch===null){
      secondTouch = { id:e.pointerId, x:e.clientX, y:e.clientY };
      return;
    }

    pointer.down = true;
    pointer.id = e.pointerId;
    const p = localXY(e);
    pointer.x = pointer.prevX = p.x;
    pointer.y = pointer.prevY = p.y;

    if(tool==='anchor'){
      anchorActive = true;
      anchorPoints.push(p);
      redrawAnchorPreview();
      return;
    }

    if(tool && tool!=='anchor'){
      beginStroke(p.x, p.y);
    }
  });

  board.addEventListener('pointermove', (e)=>{
    if(secondTouch && (e.pointerId===pointer.id || e.pointerId===secondTouch.id)){
      // ピンチ（距離の変化でscale、中心でパン）
      const t1 = (e.pointerId===pointer.id) ? {x:e.clientX, y:e.clientY} : {x:pointer.prevClientX, y:pointer.prevClientY};
      const t2 = (e.pointerId===secondTouch.id) ? {x:e.clientX, y:e.clientY} : {x:secondTouch.x, y:secondTouch.y};

      const prevDist = Math.hypot((pointer.prevClientX??pointer.x)-(secondTouch.x), (pointer.prevClientY??pointer.y)-(secondTouch.y));
      const dist = Math.hypot(t1.x - t2.x, t1.y - t2.y);
      const ratio = (prevDist===0)?1: dist/prevDist;

      scale = Math.min(3, Math.max(0.3, scale * ratio));

      // 中心の移動分をパンに加算
      const prevCx = ((pointer.prevClientX??t1.x) + secondTouch.x)/2;
      const prevCy = ((pointer.prevClientY??t1.y) + secondTouch.y)/2;
      const cx = (t1.x + t2.x)/2;
      const cy = (t1.y + t2.y)/2;
      tx += (cx - prevCx);
      ty += (cy - prevCy);

      applyTransform();
      pointer.prevClientX = t1.x; pointer.prevClientY = t1.y;
      secondTouch.x = t2.x; secondTouch.y = t2.y;
      showZoomHUD();
      return;
    }

    if(!pointer.down || tool==='anchor') return;

    const p = localXY(e);
    const spd = Math.hypot(p.x-pointer.prevX, p.y-pointer.prevY);
    drawTo(p.x, p.y, spd);
    pointer.prevX = p.x; pointer.prevY = p.y;
  });

  board.addEventListener('pointerup', (e)=>{
    if(secondTouch && e.pointerId===secondTouch.id){ secondTouch=null; return; }
    if(e.pointerId!==pointer.id){ return; }

    if(tool && tool!=='anchor'){
      endStroke();
    }
    pointer.down=false; pointer.id=null;
  });

  // ダブルクリックでアンカー確定
  board.addEventListener('dblclick', (e)=>{
    if(tool!=='anchor' || anchorPoints.length<2) return;
    finalizeAnchorStroke();
  });

  // ホイールズーム（トラックパッドピンチ対応・または ctrl+wheel）
  board.addEventListener('wheel', (e)=>{
    if(!e.ctrlKey) return; // 通常スクロールは無視
    e.preventDefault();
    const rect = board.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;

    const prevScale = scale;
    scale = Math.min(3, Math.max(0.3, scale * (e.deltaY<0 ? 1.05 : 0.95)));
    // ズーム中心を維持するように平行移動補正
    tx = cx - (cx - tx) * (scale/prevScale);
    ty = cy - (cy - ty) * (scale/prevScale);

    applyTransform();
    showZoomHUD();
  }, {passive:false});

  function applyTransform(){
    const t = `translate(${tx}px, ${ty}px) scale(${scale})`;
    mannequin.style.transform = t;
    canvases.forEach(c=>c.style.transform = t);
    grid.style.transform = t;
  }

  function showZoomHUD(){
    zoomHUD.textContent = `${Math.round(scale*100)}%`;
    zoomHUD.classList.add('show');
    clearTimeout(showZoomHUD._t);
    showZoomHUD._t = setTimeout(()=>zoomHUD.classList.remove('show'), 1000);
  }

  // ============ アンカーペン ============
  function redrawAnchorPreview(){
    // プレビューは最上段レイヤーに薄く表示
    const ctx = getActiveCtx();
    const c = canvases[activeLayer];
    // クリアしてプレビュー
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.clearRect(0,0,c.width,c.height);
    ctx.restore();

    // 既存内容は保持したいので、別にプレビューを描くのは難しい
    // -> 簡易的にガイド点のみを描画
    const g = ctx;
    g.save();
    g.strokeStyle = '#4E78DA';
    g.fillStyle = '#4E78DA';
    g.lineWidth = 1;
    for(let i=0;i<anchorPoints.length;i++){
      const p = anchorPoints[i];
      g.beginPath(); g.arc(p.x, p.y, 3, 0, Math.PI*2); g.fill();
      if(i>0){ g.beginPath(); g.moveTo(anchorPoints[i-1].x, anchorPoints[i-1].y); g.lineTo(p.x,p.y); g.stroke(); }
    }
    g.restore();
  }

  function finalizeAnchorStroke(){
    const ctx = getActiveCtx();
    if(canvases[activeLayer].hasAttribute('data-locked')) return;
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.strokeStyle = color;
    ctx.lineWidth  = size;
    ctx.lineJoin = 'round';
    ctx.lineCap  = 'round';
    ctx.beginPath();
    ctx.moveTo(anchorPoints[0].x, anchorPoints[0].y);
    for(let i=1;i<anchorPoints.length;i++){
      ctx.lineTo(anchorPoints[i].x, anchorPoints[i].y);
    }
    ctx.stroke();
    ctx.restore();
    anchorPoints.length=0; anchorActive=false;
  }

  // ============ レイアウト初期化 ============
  // 初回はグリッド非表示
  grid.classList.remove('show');

  // 自動保存（30秒ごと）
  setInterval(saveProject, 30000);
  </script>
</body>
</html>
